#/usr/bin/perl

use strict;
use warnings;
use feature qw(say);

my $lxccontainer_h = "/usr/include/lxc/lxccontainer.h";
my $attach_options_h = "/usr/include/lxc/attach_options.h";

open my $h_fh, '<', $lxccontainer_h
    or die "unable to open header file $lxccontainer_h";
open my $ha_fh, '<', $attach_options_h
    or die "unable to open header file $attach_options_h";

my $date = `date`;
chomp $date;

my $h = do { undef $/; <$h_fh> };
my $ha = do { undef $/; <$ha_fh> };

open my $methods, '>', "methods.h";
open my $constants, '>', "constants.h";

for my $fh ($methods, $constants) {
    print {$fh} <<HEAD;
/* This header generated by mk_method_wrappers from file $lxccontainer_h
 * on $date.
 *
 * Do not edit!
 */

HEAD
}

my %skip = (ATTACH_OPTIONS_DEFAULT => 1);

for ($h, $ha) {

  s{/\*.*?\*/}{}sg; # no comments

  for (/^#define\s*LXC_(\w+)/gm,
       /^\s*LXC_(\w+)/gm) {

      next if $skip{$_}++;

      print {$constants} <<EOC;
static int
lxc_$_(void) {
    return LXC_$_;
}

EOC
      print <<PROTO
int
lxc_$_()

PROTO
  }

  s{^#.*}{}gm;


  for (split /;/) {

      # enforce my style:
      s/\s+/ /gi;         # collapse spaces
      s/^ //; s/ $//;     # trim
      s/ (?=\W)//g;       # no space before symbol
      s/(?<=\W) //g;      # no space after symbol
      s/ ?, ?/, /g;       # space after comma
      s/(?<=\w)\*/ */g;   # space between word and asterisk

      if (my ($return_type, $method, $type, $args) =
          /^((?:\w+)(?:\s\w+)*(?:\s\**)?) # return type
           \(\*(\w+)\)                    # (*method)
           \(                             # (
           (\w+(?:\s\w+))\s\*             # object type
           \w+                            # object name
           ([^)]*)                        # extra args
           \)$                            # )
          /x) {

          next if $args =~ /\.\.\.$/; # skip vararg methods

          my $class = $type;
          $class =~ s/struct\s//;
          $class =~ s/\s*\*$//;
          $class =~ s/\W+/_/g;

          my @names = qw(self);
          my @decl = "$type *self";

          for (split /,\s*/, $args) {
              if (my ($decl, $name) = /^(.*?(\w+)(?:\[\])?)$/) {
                  push @names, $name;
                  push @decl, $decl;
              }
          }

          my $proto = join(', ', @names);
          my $decl = join('', map "    $_\n", @decl);



          print {$methods} <<EOF;
static $return_type
${class}_${method}(${type} *self${args}) {
    (self->${method})($proto);
}

EOF

          print <<EOP;
$return_type
${class}_${method}($proto)
$decl
EOP
      }
  }
}

